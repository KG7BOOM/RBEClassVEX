{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\nright_motor = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\narm_motor_bottom = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\nclaw_motor = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\n# AI Vision Color Descriptions\nai_vision_4__greenF = Colordesc(1, 18, 229, 106, 30, 0.32)\n# AI Vision Code Descriptions\nai_vision_4 = AiVision(Ports.PORT4, ai_vision_4__greenF)\nrange_finder_rear = Sonar(brain.three_wire_port.a)\nrange_finder_front = Sonar(brain.three_wire_port.c)\nline_tracker_right = Line(brain.three_wire_port.e)\nline_tracker_left = Line(brain.three_wire_port.f)\nIMU = Inertial(Ports.PORT9)\ncontroller_1 = Controller(PRIMARY)\narm_motor_top = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      RobotProjectCode\n#\tAuthor:       Harley, Monet, Krrish, Yanhong\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\nfrom vex import *\n\nROBOT_IDLE = 0\nCLIMB_RAMP = 1\nFOLLOW_LINE = 2\nROBOT_SEARCHING = 3\nROBOT_APPROACHING = 4\nROBOT_GRABBING = 5\nROBOT_BOX = 6\n\n\n# CURRENT MISSION ==> CLIMB RAMP\n\"\"\"\nKrrish: \n        Problem: To climb the ramp I tried to use the ultrasonic sensor and found out it is not viable to use because it is hallucinating for some reason,\n                maybe damaged?\n        Answer: So instead of using the ultrasonic sensor and LR, I was thinking to use the gyrosensor and LR to make it climb the ramp.\n                LR: To follow the line and falling off the path \n                Gyrosensor: To understand when to stop this CLIMB RAMP mission.\n                Probably I need to know can i make the robot understand that you are inclined right now?\n\"\"\"\n\ncurrent_state = ROBOT_IDLE\n\n#positive offset value = claw lower\n#negative offset value = claw higher\ncameraClawOffset = 45\n\ncameraInterval = 50\ncameraTimer = Timer()\n\nclaw_motor.set_max_torque(15,PERCENT)\narm_motor_bottom.set_max_torque(30,PERCENT)\narm_motor_top.set_max_torque(30,PERCENT)\n\nclaw_motor.set_timeout(3, SECONDS)\n\nclaw_motor.spin_for(REVERSE, 300, DEGREES, True)\nclaw_motor.spin_for(FORWARD, 150, DEGREES, False)\n\nclaw_motor.set_timeout(10000, SECONDS)\n\narm_motor_bottom.set_stopping(HOLD)\narm_motor_bottom.set_stopping(HOLD)\n\n\ndef handleButton_fruit():\n    \"\"\"\n    This is the handle function to get the fruit when the _UP_ button is pressed!\n    \"\"\"\n    global current_state\n\n    if(current_state == ROBOT_IDLE):\n        print('IDLE -> SEARCHING') ## Pro-tip: print out state _transitions_\n        current_state = ROBOT_SEARCHING\n\n        ## start the timer for the camera\n        cameraTimer.event(cameraTimerCallback, cameraInterval)\n\n    else: ## failsafe; go to IDLE from any other state when button is pressed\n        print(' -> IDLE')\n        current_state = ROBOT_IDLE\n        left_motor.stop()\n        right_motor.stop()\n\ndef handleButton_deliver():\n    \"\"\"\n    This is the handle function to deliver the fruit when the _DOWN_ button is pressed!\n    \"\"\"\n    pass\n\n\ncontroller_1.buttonUp.pressed(handleButton_fruit)\n\n\n\ndef cameraTimerCallback():\n    global current_state\n    global missedDetections\n\n    ## Here we use a checker-handler, where the checker checks if there is a new object detection.\n    ## We don't use a \"CheckForObjects()\" function because take_snapshot() acts as the checker.\n    ## It returns a non-empty list if there is a detection.\n    objects = ai_vision_4.take_snapshot(ai_vision_4__greenF)\n    if objects: handleObjectDetection()\n\n    # restart the timer\n    if(current_state != ROBOT_IDLE):\n        cameraTimer.event(cameraTimerCallback, cameraInterval)\n\ndef handleObjectDetection():\n    global current_state\n    global object_timer\n\n    if current_state == ROBOT_SEARCHING:\n        print('SEARCHING -> APPROACHING') ## Pro-tip: print out state _transitions_\n        current_state = ROBOT_APPROACHING\n\n    ## Not elif, because we want the logic to cascade\n    if current_state == ROBOT_APPROACHING:\n\n        cx = ai_vision_4.largest_object().centerX\n        cy = ai_vision_4.largest_object().centerY\n        YHeight = ai_vision_4.largest_object().height\n        XWidth = ai_vision_4.largest_object().width\n\n        fruitCenterY = cy + cameraClawOffset\n\n        target_x = 160\n        K_x = 0.5\n\n        error = cx - target_x\n        turn_effort = K_x * error\n\n        target_arm = 117\n        K_arm = 0.5\n\n        errorArm = fruitCenterY - target_arm\n        arm_effort = K_arm * errorArm\n\n\n        ## TODO: Edit code to approach or back up to hold the right position\n        left_motor.spin(REVERSE, 80 + turn_effort)\n        right_motor.spin(FORWARD, 80 - turn_effort)\n        arm_motor_bottom.spin(REVERSE, 25 - arm_effort)\n        arm_motor_top.spin(REVERSE, 25 - arm_effort)\n\n        constantVal = .3048*54\n        output = constantVal/YHeight\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print(output)\n\n        if output < .1:\n            current_state = ROBOT_GRABBING\n    \n    if current_state == ROBOT_GRABBING:\n        arm_motor_bottom.stop()\n        arm_motor_top.stop()\n\n        left_motor.spin_for(REVERSE, 220, DEGREES, False)\n        right_motor.spin_for(FORWARD, 220, DEGREES, True)\n        claw_motor.spin(REVERSE, 30)\n        wait(3, SECONDS)\n        left_motor.spin_for(FORWARD, 2000, DEGREES, False)\n        right_motor.spin_for(REVERSE, 2000, DEGREES, True)\n\n\n        current_state = ROBOT_BOX\n\ndef turn_left():\n    left_motor.spin_for(REVERSE, 1000,DEGREES,wait=False)\n    right_motor.spin_for(FORWARD, 1000,DEGREES)\n    brain.screen.set_cursor(5,1)\n    brain.screen.print('turned left')\n    while True:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n        if lr > 40 or rr > 40:\n            break\n        else:\n           left_motor.spin(REVERSE, 400, DPS)\n           right_motor.spin(FORWARD, 300, DPS)\n\ndef follow_line():\n\n    while range_finder_front.distance(MM) > 300:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr = line_tracker_right.reflectivity(PERCENT)\n        effortl = (95 - lr)*2.5\n        effortr = (95 - rr)*2.5\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n\n        if (lr > 30) and (rr > 30):\n            right_motor.stop()\n            left_motor.stop()\n        else:\n            left_motor.spin(REVERSE, (750 + effortl - effortr), DPS)\n            right_motor.spin(FORWARD, (750 - effortl + effortr), DPS)\n    brain.screen.set_cursor(9,10)\n    brain.screen.print('object detected!')\n\n\n\n\ndef move_forward():\n    # This program is just to move the robot forward for a small time.\n    left_motor.spin_for(FORWARD,750,DEGREES,wait=False)\n    right_motor.spin_for(FORWARD,750,DEGREES,wait=True)\n\ndef climb_ramp():\n    \"use inertial.calibrate() and inertial.set_heading() before this program\"\n    play_vexcode_sound('climbing ramp')\n    \n    # Here I want a while loop that until the z axis is return to its original 0 keep tracking line and move forward!\n    while IMU.orientation(OrientationType.ROLL,DEGREES) > 1:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr = line_tracker_right.reflectivity(PERCENT)\n        effortl = (95 - lr)*2.5\n        effortr = (95 - rr)*2.5\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n\n        if (lr < 30) and (rr < 30):\n            right_motor.stop()\n            left_motor.stop()\n        else:\n            left_motor.spin(FORWARD, (750 + effortl - effortr), DPS)\n            right_motor.spin(FORWARD, (750 - effortl + effortr), DPS)\n    brain.screen.set_cursor(9,10)\n    brain.screen.print('Climbed RAMP!')\n\n\n\n# Start of our robot!\n\nIMU.calibrate()\nIMU.set_heading(0,DEGREES)\nwhile IMU.orientation(OrientationType.ROLL,DEGREES) < 2:\n    move_forward()\nclimb_ramp()\nfollow_line()\nturn_left()\nright_motor.stop()\nleft_motor.stop()\n\n    \n\n# After math of successful mission :---> CLIMB RAMP + FOLLOW LINE + GRAB FRUIT\n\"\"\"\nKrrish: Approaches I am thinking, What if when it goes to approach state, and would start remembering its movement, and would just replicate them\n        in reverse vector going backward ending up on the line and then going to deliver the fruit?\n\"\"\"","textLanguage":"python","robotConfig":[{"port":[10],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"arm_motor_bottom","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"claw_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"ai_vision_4","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[{\"id\":1,\"name\":\"greenF\",\"nameValid\":\"Valid\",\"lastValidName\":\"greenF\",\"red\":18.260162601626018,\"green\":228.61314363143632,\"blue\":105.63956639566396,\"hueRange\":30,\"saturationRange\":0.32}],\"codes\":[],\"tags\":false,\"AIObjects\":false,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"AIModelMetadata\":{\"id\":0,\"version\":1,\"name\":\"Classroom Objects\"},\"aiModelDropDownValue\":0}","isConfigured":"false"},"triportSourcePort":22},{"port":[1,2],"name":"range_finder_rear","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[3,4],"name":"range_finder_front","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[5],"name":"line_tracker_right","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[6],"name":"line_tracker_left","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[9],"name":"IMU","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[6],"name":"arm_motor_top","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.61.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}