{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\nright_motor = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\narm_motor_bottom = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\nclaw_motor = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\n# AI Vision Color Descriptions\nai_vision_4__greenF = Colordesc(1, 18, 229, 106, 30, 0.32)\n# AI Vision Code Descriptions\nai_vision_4 = AiVision(Ports.PORT4, ai_vision_4__greenF)\nrange_finder_rear = Sonar(brain.three_wire_port.a)\nrange_finder_front = Sonar(brain.three_wire_port.c)\nline_tracker_right = Line(brain.three_wire_port.e)\nline_tracker_left = Line(brain.three_wire_port.f)\nIMU = Inertial(Ports.PORT9)\ncontroller_1 = Controller(PRIMARY)\narm_motor_top = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      RobotProjectCode\n#\tAuthor:       Harley, Monet, Krrish, Yanhong\n#\tCreated:\n#\tDescription:  Robot to Harvest fruit\n# \n# ------------------------------------------\n\n\n\"\"\"\nBefore we start anything,\nRemeber our Motors were set like this:\n\n    RIGHT MOTOR: Normal (Port 1).\n    LEFT MOTOR: Reverse (Port 10).\n    ARM MOTOR TOP: Normal (Port 6).\n    ARM MOTOR BOTTOM: Normal (Port 8).\n\nWhen we say right or left here, we mean right and left from robots view.\nThe front of our robot is where we have 'mecanum wheels' also known as 'rollers'.\nThe back of our robot is where we have traction wheels.\n\nIn this code also in Robot we have sensors connected as follows: \n\n   S.no   |     Sensor                            |     Name (Port)\n    1)    |    Ultrasonic Range Finder (Front)    |   range_finder_front (C,D)\n    2)    |    Ultrasonic Range Finder (Back)     |   range_finder_rear  (A,B) \n    3)    |    Light Reflector Sensor  (Right)    |   line_tracker_right (E)\n    4)    |    Light Reflector Sensor  (Left)     |   line_tracker_right (F)\n    5)    |    Interial Sensor         (Mid Left) |   IMU                (9)\n\n\"\"\"\nfrom vex import *\n\nROBOT_IDLE = 0\nCLIMB_RAMP = 1\nFOLLOW_LINE = 2\nROBOT_SEARCHING = 3\nROBOT_APPROACHING = 4\nROBOT_GRABBING = 5\nROBOT_BOX = 6\n\n\n# CURRENT MISSION ==> CLIMB RAMP\n\"\"\"\nKrrish: \n        Problem: To climb the ramp I tried to use the ultrasonic sensor and found out it is not viable to use because it is hallucinating for some reason,\n                maybe damaged?\n        Answer: So instead of using the ultrasonic sensor and LR, I was thinking to use the gyrosensor and LR to make it climb the ramp.\n                LR: To follow the line and falling off the path \n                Gyrosensor: To understand when to stop this CLIMB RAMP mission.\n                Probably I need to know can i make the robot understand that you are inclined right now?\n        Update (9/30/2025): Now This plan is working perfectly as planed.\n\"\"\"\n\ncurrent_state = ROBOT_IDLE\n\n#positive offset value = claw lower\n#negative offset value = claw higher\ncameraClawOffset = 45\n\ncameraInterval = 50\ncameraTimer = Timer()\n\nclaw_motor.set_max_torque(15,PERCENT)\narm_motor_bottom.set_max_torque(30,PERCENT)\narm_motor_top.set_max_torque(30,PERCENT)\n\nclaw_motor.set_timeout(3, SECONDS)\n\nclaw_motor.spin_for(REVERSE, 300, DEGREES, True)\nclaw_motor.spin_for(FORWARD, 150, DEGREES, False)\n\nclaw_motor.set_timeout(10000, SECONDS)\n\narm_motor_bottom.set_stopping(HOLD)\narm_motor_bottom.set_stopping(HOLD)\n\n\ndef handleButton_fruit():\n    \"\"\"\n    This is the handle function to get the fruit when the _UP_ button is pressed!\n    \"\"\"\n    global current_state\n\n    if(current_state == ROBOT_IDLE):\n        print('IDLE -> SEARCHING') ## Pro-tip: print out state _transitions_\n        current_state = ROBOT_SEARCHING\n\n        ## start the timer for the camera\n        cameraTimer.event(cameraTimerCallback, cameraInterval)\n\n    else: ## failsafe; go to IDLE from any other state when button is pressed\n        print(' -> IDLE')\n        current_state = ROBOT_IDLE\n        left_motor.stop()\n        right_motor.stop()\n\n\ndef handleButton_deliver():\n    \"\"\"\n    This is the handle function to deliver the fruit when the _DOWN_ button is pressed!\n    \"\"\"\n    pass\n\n\n# controller_1.buttonUp.pressed(handleButton_fruit) - I am making this automatic\n\n\n\ndef cameraTimerCallback():\n    global current_state\n    global missedDetections\n\n    ## Here we use a checker-handler, where the checker checks if there is a new object detection.\n    ## We don't use a \"CheckForObjects()\" function because take_snapshot() acts as the checker.\n    ## It returns a non-empty list if there is a detection.\n    objects = ai_vision_4.take_snapshot(ai_vision_4__greenF)\n    if objects: handleObjectDetection()\n\n    # restart the timer\n    if(current_state != ROBOT_IDLE):\n        cameraTimer.event(cameraTimerCallback, cameraInterval)\n\ndef handleObjectDetection():\n    global current_state\n    global object_timer\n\n    if current_state == ROBOT_SEARCHING:\n        print('SEARCHING -> APPROACHING') ## Pro-tip: print out state _transitions_\n        current_state = ROBOT_APPROACHING\n\n    ## Not elif, because we want the logic to cascade\n    if current_state == ROBOT_APPROACHING:\n\n        cx = ai_vision_4.largest_object().centerX\n        cy = ai_vision_4.largest_object().centerY\n        YHeight = ai_vision_4.largest_object().height\n        XWidth = ai_vision_4.largest_object().width\n\n        fruitCenterY = cy + cameraClawOffset\n\n        target_x = 160\n        K_x = 0.5\n\n        error = cx - target_x\n        turn_effort = K_x * error\n\n        target_arm = 117\n        K_arm = 0.5\n\n        errorArm = fruitCenterY - target_arm\n        arm_effort = K_arm * errorArm\n\n\n        ## TODO: Edit code to approach or back up to hold the right position\n        left_motor.spin(FORWARD, 80 + turn_effort) # this was REVERSE in \n        right_motor.spin(FORWARD, 80 - turn_effort) # this was FORWARD\n        arm_motor_bottom.spin(REVERSE, 25 - arm_effort)\n        arm_motor_top.spin(REVERSE, 25 - arm_effort)\n\n        constantVal = .3048*54\n        output = constantVal/YHeight\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print(output)\n\n        if output < .1:\n            current_state = ROBOT_GRABBING\n    \n    if current_state == ROBOT_GRABBING:\n\n        # A safety protocol is still needed!\n        arm_motor_bottom.stop()\n        arm_motor_top.stop()\n\n        left_motor.spin_for(FORWARD, 220, DEGREES, False)\n        right_motor.spin_for(FORWARD, 220, DEGREES, True)\n        claw_motor.spin(REVERSE, 30)\n        wait(3, SECONDS)\n        left_motor.spin_for(REVERSE, 2000, DEGREES, False)\n        right_motor.spin_for(REVERSE, 2000, DEGREES, True)\n        \n        arm_motor_bottom.spin(FORWARD, 30) # here is krrish edits come!!\n        \n        arm_motor_top.spin(FORWARD, 30)\n        claw_motor.spin(FORWARD,30)\n\n\n\n        current_state = ROBOT_BOX\n\ndef turn_left():\n    left_motor.spin_for(REVERSE, 1000,DEGREES,wait=False)\n    right_motor.spin_for(FORWARD, 1000,DEGREES)\n    brain.screen.set_cursor(5,1)\n    brain.screen.print('turned left')\n    # Now the code doesn't need the part below!\n    \n\"\"\"    while True:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n         \n        if lr > 40 or rr > 40:\n            break\n        else:\n           left_motor.spin(FORWARD, 400, DPS)\n           right_motor.spin(REVERSE, 300, DPS)\n\"\"\"\n\ndef follow_line(threshold):\n\n    while range_finder_front.distance(MM) > threshold:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr = line_tracker_right.reflectivity(PERCENT)\n        effortl = (95 - lr)*2.5\n        effortr = (95 - rr)*2.5\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n\n        \n        if (lr < 30) and (rr < 30):\n            right_motor.stop()\n            left_motor.stop()\n        else:\n            left_motor.spin(FORWARD, (750 + effortl - effortr), DPS)\n            right_motor.spin(FORWARD, (750 - effortl + effortr), DPS)\n    brain.screen.set_cursor(9,10)\n    brain.screen.print('object detected!')\n\n\n\n\ndef move_forward():\n    # This program is just to move the robot forward for a small time.\n    left_motor.spin_for(FORWARD,750,DEGREES,wait=False)\n    right_motor.spin_for(FORWARD,750,DEGREES,wait=True)\n\ndef climb_ramp():\n    \"use inertial.calibrate() and inertial.set_heading() before this program\"\n    play_vexcode_sound('climbing ramp')\n    \n    # Here I want a while loop that until the z axis is return to its original 0 keep tracking line and move forward!\n    while IMU.orientation(OrientationType.ROLL,DEGREES) > 1:\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr = line_tracker_right.reflectivity(PERCENT)\n        effortl = (95 - lr)*2.5\n        effortr = (95 - rr)*2.5\n        lr = line_tracker_left.reflectivity(PERCENT)\n        rr= line_tracker_right.reflectivity(PERCENT)\n        brain.screen.set_cursor(3,1)\n        brain.screen.print('lr' ,lr , 'rr', rr)\n\n        if (lr < 30) and (rr < 30):\n            right_motor.stop()\n            left_motor.stop()\n        else:\n            left_motor.spin(FORWARD, (750 + effortl - effortr), DPS)\n            right_motor.spin(FORWARD, (750 - effortl + effortr), DPS)\n    brain.screen.set_cursor(9,10)\n    brain.screen.print('Climbed RAMP!')\n\n\n\n# Start of our robot!\n\ndef main_program():\n    IMU.calibrate()\n    IMU.set_heading(0,DEGREES)\n\n    while IMU.orientation(OrientationType.ROLL,DEGREES) < 2:\n        move_forward()\n\n    climb_ramp()\n    follow_line(300)\n    turn_left()\n    handleButton_fruit()\n\n    right_motor.stop()\n    left_motor.stop()\n\n\ncontroller_1.buttonA.pressed(main_program)  \n\n# After math of successful mission :---> CLIMB RAMP + FOLLOW LINE + GRAB FRUIT\n\"\"\"\nKrrish: Now since we have the fruit, we are going to fallback to white line using simple logic, previously I had an idea,\n        but it was very messy and difficult, where this is easy and reliable!\n\nThoughts: Here I am thinking to follow the Harley's checkpoint, where his commands makes it move backward,\n          The tunning I want to do is I will use the ultrasonic rangefinder to stop before colliding to wall.\n\nPlanning: As said above using Harley's checkpoint, we are gonna tell that until you detect something in the range\n          of 200 mm keep going backward, and rotate and move but with caution until you find the white line,\n          after that use the follow_line() command but with different Ultrasonic rangefinder reading until you find\n          the basket with the color sensor.\n\"\"\"","textLanguage":"python","robotConfig":[{"port":[10],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"arm_motor_bottom","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"claw_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"ai_vision_4","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[{\"id\":1,\"name\":\"greenF\",\"nameValid\":\"Valid\",\"lastValidName\":\"greenF\",\"red\":18.260162601626018,\"green\":228.61314363143632,\"blue\":105.63956639566396,\"hueRange\":30,\"saturationRange\":0.32}],\"codes\":[],\"tags\":false,\"AIObjects\":false,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"AIModelMetadata\":{\"id\":0,\"version\":1,\"name\":\"Classroom Objects\"},\"aiModelDropDownValue\":0}","isConfigured":"false"},"triportSourcePort":22},{"port":[1,2],"name":"range_finder_rear","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[3,4],"name":"range_finder_front","customName":true,"deviceType":"RangeFinder","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[5],"name":"line_tracker_right","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[6],"name":"line_tracker_left","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[9],"name":"IMU","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[6],"name":"arm_motor_top","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.61.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}